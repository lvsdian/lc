
- [数组](#数组)
  - [03.数组中重复出现的数字](#03数组中重复出现的数字)
  - [04. 二维数组中的查找](#04-二维数组中的查找)
  - [05. 替换空格](#05-替换空格)
  - [06. 从尾到头打印链表](#06-从尾到头打印链表)
  - [11. 旋转数组的最小数字](#11-旋转数组的最小数字)
  - [21. 调整数组顺序使奇数位于偶数前面](#21-调整数组顺序使奇数位于偶数前面)
  - [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
  - [39. 数组中出现次数超过一半的数字](#39-数组中出现次数超过一半的数字)
  - [40. 最小的k个数 快排/堆排(PriorityQueue)](#40-最小的k个数-快排堆排priorityqueue)
  - [41. 数据流中的中位数 堆(PriorityQueue)](#41-数据流中的中位数-堆priorityqueue)
- [链表](#链表)
  - [18. 删除链表的节点](#18-删除链表的节点)
  - [22. 链表中倒数第k个节点](#22-链表中倒数第k个节点)
  - [24. 反转链表](#24-反转链表)
  - [25. 合并两个排序的链表](#25-合并两个排序的链表)
  - [35. 复杂链表的复制](#35-复杂链表的复制)
  - [36. 二叉搜索树与双向链表](#36-二叉搜索树与双向链表)
- [树](#树)
  - [07. 重建二叉树](#07-重建二叉树)
  - [26. 树的子结构](#26-树的子结构)
  - [27. 二叉树的镜像](#27-二叉树的镜像)
  - [28. 对称的二叉树](#28-对称的二叉树)
  - [32 - I. 从上到下打印二叉树](#32---i-从上到下打印二叉树)
  - [32 - II. 从上到下打印二叉树 II](#32---ii-从上到下打印二叉树-ii)
  - [32 - III. 从上到下打印二叉树 III](#32---iii-从上到下打印二叉树-iii)
  - [33. 二叉搜索树的后序遍历序列](#33-二叉搜索树的后序遍历序列)
  - [34. 二叉树中和为某一值的路径 回溯](#34-二叉树中和为某一值的路径-回溯)
  - [37. 序列化二叉树](#37-序列化二叉树)
- [栈/队列](#栈队列)
  - [09. 用两个栈实现队列](#09-用两个栈实现队列)
  - [30. 包含min函数的栈](#30-包含min函数的栈)
  - [31. 栈的压入、弹出序列](#31-栈的压入弹出序列)
- [DP](#dp)
  - [10- I. 斐波那契数列](#10--i-斐波那契数列)
  - [10- II. 青蛙跳台阶问题](#10--ii-青蛙跳台阶问题)
  - [14- I. 剪绳子](#14--i-剪绳子)
  - [14- II. 剪绳子 II](#14--ii-剪绳子-ii)
  - [19. 正则表达式匹配](#19-正则表达式匹配)
  - [42. 连续子数组的最大和 dp](#42-连续子数组的最大和-dp)
- [贪心](#贪心)
  - [14- I. 剪绳子](#14--i-剪绳子-1)
  - [14- II. 剪绳子 II](#14--ii-剪绳子-ii-1)
- [回溯/DFS/BFS](#回溯dfsbfs)
  - [12. 矩阵中的路径](#12-矩阵中的路径)
  - [13. 机器人的运动范围](#13-机器人的运动范围)
- [二进制](#二进制)
  - [15. 二进制中1的个数](#15-二进制中1的个数)
  - [16. 数值的整数次方--快速幂](#16-数值的整数次方--快速幂)
  - [17. 打印从1到最大的n位数--快速幂](#17-打印从1到最大的n位数--快速幂)
- [字符串](#字符串)
  - [20. 表示数值的字符串](#20-表示数值的字符串)
  - [38. 字符串的排列](#38-字符串的排列)
- [其他](#其他)
  - [43. 1～n整数中1出现的次数](#43-1n整数中1出现的次数)
  - [44. 数字序列中某一位的数字](#44-数字序列中某一位的数字)
### 数组

#### [03.数组中重复出现的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

> 在一个**长度为 n**的数组 nums 里的所有数字都在 **0～n-1** 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中**任意一个**重复的数字。
>
> ```
> 2 <= n <= 100000,
> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3 
> ```

```java
    // 哈希表
	public int findRepeatNumber(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i = 0;i < nums.length;i ++){
            if(map.containsKey(nums[i])){
                return nums[i];
            }
            map.put(nums[i],i);
        }
        throw new IllegalArgumentException("数组中不存在重复数字！");
    }
	// 数组，根据题目所给信息，哈希表不是最好做法
    public int findRepeatNumber(int[] nums) {
       for(int i = 0;i < nums.length;i ++){
           while(i != nums[i]){
                // 比如[1,1,1]
                if(nums[i] == nums[nums[i]]){
                    return nums[i];
                }
                swap(nums,nums[i],i);
           }
       }    
       throw new IllegalArgumentException("数组中不存在重复数字！");        
    }
    private void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
```

#### [04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

> 在一个 n * m 的二维数组中，每一行都按照从**左到右递增**的顺序排序，每一列都按照从**上到下递增**的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
>
> ```
> 0 <= n <= 1000
> 0 <= m <= 1000
> 
> 现有矩阵 matrix 如下：
> [
>   [1,   4,  7, 11, 15],
>   [2,   5,  8, 12, 19],
>   [3,   6,  9, 16, 22],
>   [10, 13, 14, 17, 24],
>   [18, 21, 23, 26, 30]
> ]
> 给定 target = 5，返回 true。
> 给定 target = 20，返回 false。
> ```

```java
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        // 非空判断
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return false;
        }
        int i = 0,j = matrix[0].length - 1;
        while(i < matrix.length && j >= 0){
            if(target == matrix[i][j]){
                return true;
            }else if(target < matrix[i][j]){
                j --;
            }else{
                i ++;
            }
        }
        return false;
    }
```

#### [05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

> 请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。
>
> ```
> 0 <= s 的长度 <= 10000
> 示例 1：
> 输入：s = "We are happy."
> 输出："We%20are%20happy."
> ```

```java
    public String replaceSpace(String s) {
        // 非空判断
        if(s == null || s.length() == 0){
            return s;
        }
        // 统计空格数量
        int spaceCount = 0;
        for(int i = 0;i < s.length();i ++){
            if(' ' == s.charAt(i)){
                spaceCount ++;
            }
        }
        // 新字符串长度
        int newLen = s.length() + spaceCount * 2;
        char[] ch = new char[newLen];
        int j = s.length() - 1;
        int i = newLen - 1;
        //从后往前替换
        while(j >= 0){
            if(' ' != s.charAt(j)){
                ch[i--] = s.charAt(j--);
            }else{
                j --;
                ch[i --] = '0';
                ch[i --] = '2';
                ch[i --] = '%';
            }
        }
        return new String(ch);
    }
```

#### [06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

> 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
>
> ```
> 0 <= 链表长度 <= 10000
> 示例 1：
> 输入：head = [1,3,2]
> 输出：[2,3,1]
> ```

```java
	public class ListNode {
		int val;
		ListNode next;
		ListNode(int x) { val = x; }
  	}    
	// 使用栈
	public int[] reversePrint(ListNode head) {
        if(head == null){
            return new int[]{};
        }
        Stack<Integer> stack = new Stack<>();
        while(head != null){
            stack.push(head.val);
            head = head.next;
        }
        int[] arr = new int[stack.size()];
        for(int i = 0;i < arr.length;i ++){
            arr[i] = stack.pop();
        }
        return arr;
    }
```

#### [11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  
>
> ```java
> 示例 1：
> 
> 输入：[3,4,5,1,2]
> 输出：1
> 示例 2：
> 
> 输入：[2,2,2,0,1]
> 输出：0
> ```

```java
    //三种case：1.示例情况；2.数组已经有序；3.101111特殊情况
	public int minArray(int[] numbers) {
        if(numbers == null || numbers.length <= 0){
            throw new IllegalArgumentException("invalid args");
        }
        int left = 0;
        int right = numbers.length - 1;
        int mid = left;
        while(numbers[left] >= numbers[right]){
            if(right - left == 1){
                mid = right;
                break;
            }
            mid = (left + right) >> 1;
            if(numbers[left] == numbers[mid] && numbers[mid] == numbers[right]){
                return getMin(numbers);
            }else if(numbers[left] <= numbers[mid]){
                left = mid;
            }else if(numbers[left] >= numbers[mid]){
                right = mid;
            }
        }
        return numbers[mid];
    }
    public int getMin(int[] arr){
        int ele = 0x3f3f3f;
        for(int i = 0;i < arr.length;i ++){
            if(arr[i] <= ele){
                ele = arr[i];
            }
        }
        return ele;
    }
```

#### [21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。**保持元素相对顺序不变**
>
> ```
> 1 <= nums.length <= 50000
> 1 <= nums[i] <= 10000
> 
> 示例：
> 
> 输入：nums = [1,2,3,4]
> 输出：[1,3,2,4] 
> 注：[3,1,2,4] 也是正确的答案之一。
> ```

```java
    // [0,i]位置为奇数，[j,nums.length - 1]位置为偶数
    public int[] exchange(int[] nums) {
        if(nums == null || nums.length <= 1){
            return nums;
        }
        int i = 0,j,tmp;
        while(i < nums.length -1){
            j = i + 1;
            if((nums[i] & 1) == 0){
                while((nums[j] & 1) == 0){
                    j ++;
                    if(j >= nums.length){
                        return nums;
                    }
                }
                tmp = nums[j];
                for(int k = j;k > i ;k --){
                    nums[k] = nums[k - 1];
                }
                nums[i] = tmp;
            }
            i ++;
        }
        return nums;
    }
```

#### [29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

```java
    public int[] spiralOrder(int[][] matrix) {
        //非空判断
        if(matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0){
            return new int[0];
        }
        int[] arr = new int[matrix.length * matrix[0].length];

        int up = 0,left = 0,right = matrix[0].length - 1,down = matrix.length - 1, x = 0;
        while(true){
            //从左上到右上
            for(int col = left;col <= right;col ++){
                arr[x ++] = matrix[up][col];
            }
            up ++;
            if(up > down){
                break;
            }
            //从右上到右下
            for(int row = up;row <= down;row ++){
                arr[x ++] = matrix[row][right];
            }
            right --;
            if(left > right){
                break;
            }
            //从右下到左下
            for(int col = right;col >= left;col --){
                arr[x ++] = matrix[down][col];
            }
            down --;
            if(down < up){
                break;
            }
            //从左下到左上
            for(int row = down;row >= up;row --){
                arr[x ++] = matrix[row][left];
            }
            left ++;
            if(right < left){
                break;
            }
        }
        return arr;
    }
```
#### [39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)
> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1:
```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```
```java
    // Hashmap,时间空间都是O(N)
    public int majorityElement(int[] nums) {
        if (nums.length == 1) return nums[0];
        int half = (nums.length + 1) >> 1;
        int count = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                count = map.get(nums[i]);
                if (++count >= half) {
                    return nums[i];
                }
                map.put(nums[i], count);
            } else {
                map.put(nums[i], 1);
            }
        }
        return -1;
    }

    // 时间O(N),空间O(1)
    public int majorityElement(int[] nums) {
        if (nums.length == 1) 
            return nums[0];
        int votes = 0,tmp = 0;
        for(int num: nums) {
            // 每次抵消时，更新tmp
            if (votes == 0) {
                tmp = num;
            }
            votes = tmp == num ? ++votes : --votes;
        }
        return tmp;
    }
```
#### [40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) 快排/堆排(PriorityQueue)
> 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 

示例 1：
```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```
示例 2：
```
输入：arr = [0,1,2,1], k = 1
输出：[0]
```
```java
    // 快排做法
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length == 0) {
            return new int[0];
        }
        // 最后一个参数表示我们要找的是下标为k-1的数
        return quickSearch(arr, 0, arr.length - 1, k - 1);
    }

    private int[] quickSearch(int[] nums, int lo, int hi, int k) {
        // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
        int j = partition(nums, lo, hi);
        if (j == k) {
            return Arrays.copyOf(nums, j + 1);
        }
        // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
        return j > k? quickSearch(nums, lo, j - 1, k): quickSearch(nums, j + 1, hi, k);
    }
    private int partition(int[] nums, int lo, int hi) {
        int ele = nums[lo];
        int start = lo, end = hi;
        while(start != end) {
            // 这里是 >
            while(start < end && nums[end] > ele) {
                end --;
            }
            // 这里是 <=
            while(start < end && nums[start] <= ele) {
                start ++;
            }
            if (start < end) {
                swap(nums, start, end);
            }
        }
        swap(nums, start, lo);
        return start;
    }
    private void swap(int[] nums, int lo, int hi) {
        int tmp = nums[lo];
        nums[lo] = nums[hi];
        nums[hi] = tmp;
    }
    
    // 堆排做法
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length == 0) {
            return new int[0];
        }
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1);
        for (int num: arr) {
            if (pq.size() < k) {
                pq.offer(num);
            } else if (num < pq.peek()) {
                pq.poll();
                pq.offer(num);
            }
        }
        
        // 返回堆中的元素
        int[] res = new int[pq.size()];
        int idx = 0;
        for(int num: pq) {
            res[idx++] = num;
        }
        return res;
    }
```
#### [41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) 堆(PriorityQueue)
> 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
> 例如，[2,3,4] 的中位数是 3，[2,3] 的中位数是 (2 + 3) / 2 = 2.5
> 设计一个支持以下两种操作的数据结构：
> - void addNum(int num) - 从数据流中添加一个整数到数据结构中。
> - double findMedian() - 返回目前所有元素的中位数。
示例 1：
```
输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
```
示例 2：
```
输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]
```
```java
class MedianFinder {
    Queue<Integer> A, B;
    public MedianFinder() {
        A = new PriorityQueue<>(); // 小顶堆，保存较大的一半
        B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半
    }
    public void addNum(int num) {
        if(A.size() != B.size()) {
            A.add(num);
            B.add(A.poll());
        } else {
            B.add(num);
            A.add(B.poll());
        }
    }
    public double findMedian() {
        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
    }
}
```

### 链表

#### [18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

> 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
>
> 返回删除后的链表的头节点。
>
> **注意：**此题对比原题有改动
>
> ```
> 题目保证链表中节点的值互不相同
> 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
> 
> 示例 1:
> 
> 输入: head = [4,5,1,9], val = 5
> 输出: [4,1,9]
> 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
> 示例 2:
> 
> 输入: head = [4,5,1,9], val = 1
> 输出: [4,5,9]
> 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
> ```

```java
	class ListNode {
    	int val;
    	ListNode next;
    	ListNode(int x) { val = x; }
	} 	

	public ListNode deleteNode(ListNode head, int val) {
        ListNode header = new ListNode(0);
        header.next = head;
        ListNode fast = header.next;
        ListNode slow = header;
        while(fast != null){
            if(fast.val == val){
                slow.next = fast.next;
                fast.next = null;
                break;
            }
            fast = fast.next;
            slow = slow.next;
        }
        return header.next;
    }
```

#### [22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
>
> ```
> 给定一个链表: 1->2->3->4->5, 和 k = 2.
> 
> 返回链表 4->5.
> ```

```java
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode header = new ListNode(0);
        header.next = head;
        ListNode fast = header;
        ListNode slow = header;
        while(k > 0) {
            if(fast == null){
                throw new IllegalArgumentException("error");
            }
            fast = fast.next;
            k --;
        }
        while(fast != null){
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
```

#### [24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
>
> ```
> 输入: 1->2->3->4->5->NULL
> 输出: 5->4->3->2->1->NULL
> ```

```java
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode next = null;
        while(cur != null) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
```

#### [25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

> 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
>
> ```
> 输入：1->2->4, 1->3->4
> 输出：1->1->2->3->4->4
> ```

```java
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode header = new ListNode(0);
        ListNode cur = header;
        while(l1 != null && l2 != null){
            if(l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            }else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        while(l1 != null){
            cur.next = l1;
            l1 = l1.next;
            cur = cur.next;
        }
        while(l2 != null){
            cur.next = l2;
            l2 = l2.next;
            cur = cur.next;
        }
        return header.next;
    }
```
#### [35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)
> 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
```java
    /*
    // Definition for a Node.
    class Node {
        int val;
        Node next;
        Node random;

        public Node(int val) {
            this.val = val;
            this.next = null;
            this.random = null;
        }
    }
    */ 
    //HashMap实现
    public Node copyRandomList(Node head) {
        HashMap<Node,Node> map = new HashMap<>(); //创建HashMap集合
        Node cur=head;
        //复制结点值
        while(cur!=null){
            //顺序遍历，存储老结点和新结点(先存储新创建的结点值)
            map.put(cur,new Node(cur.val)); 
            cur=cur.next;
        }
        //复制结点指向
        cur = head;
        while(cur!=null){
            //新结点next指向同旧结点的next指向
            map.get(cur).next = map.get(cur.next); 
            //新结点random指向同旧结点的random指向
            map.get(cur).random = map.get(cur.random); 
            cur = cur.next;
        }
        //返回复制的链表
        return map.get(head);
    }
```
#### [36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)
> 输入一棵**二叉搜索树**，将该二叉搜索树转换成一个**排序**的**循环双向链表**。要求不能创建任何新的节点，只能调整树中节点指针的指向。
```java
    public Node treeToDoublyList(Node root) {
        if (root == null) {
            return root;
        }
        // 首尾相连变成环形链表
        Node head = dfs(root);
        while(root != null && root.right != null){
            root = root.right;
        }
        head.left = root;
        root.right = head;
        return head;
    }
    // 将树变成双向链表(非环)
    private Node dfs(Node root) {
        if(root == null){
            return null;
        }
        //将左子树转成链表，此时left指向左子树链表的头
        Node left = dfs(root.left);
        //让p移到链表末尾
        Node p = left;
        while(p != null && p.right != null){
            p = p.right;
        }
        //将root放到p后面，p一定要移到末尾后才能放root
        if(left != null){
            p.right = root;
            root.left = p;
        }
        //right放到root后面
        Node right = dfs(root.right);
        if(right != null){
            root.right = right;
            right.left = root;
        }
        return  left !=null ? left : root;
    }
```

### 树

#### [07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

> 输入某二叉树的**前序遍历**和**中序遍历**的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
>
> ```
> 0 <= 节点个数 <= 5000
> 例如，给出
> 前序遍历 preorder = [3,9,20,15,7]
> 中序遍历 inorder = [9,3,15,20,7]
> 返回如下的二叉树：
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```

```java
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 递归求解，所以这里不能判空，要判0
        if(preorder.length == 0 || inorder.length == 0){
            return null;
        }
        TreeNode tree = new TreeNode(preorder[0]);
        for(int i = 0;i <inorder.length;i ++){
            if(inorder[i] == preorder[0]){
                tree.left = 
                    buildTree(Arrays.copyOfRange(preorder,1,i + 1),Arrays.copyOfRange(inorder,0,i));
                tree.right = 
                    buildTree(Arrays.copyOfRange(preorder,i + 1,preorder.length),Arrays.copyOfRange(inorder,i + 1,inorder.length));
                break;
            }
        }
        return tree;
    }
```

#### [26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

> 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
>
> B是A的子结构， 即 A中有出现和B相同的结构和节点值。
>
> 例如:
> 给定的树 A:
>
> ```
>      3
>     / \
>    4   5
>   / \
>  1   2
> ```
>
> 给定的树B:
>
> ```
>    4 
>   /
>  1
> ```
>
> 
>
> 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
>
> 示例 1：
>
> ```
> 输入：A = [1,2,3], B = [3,1]
> 输出：false
> ```
>
>
> 示例 2：
>
> ```
> 输入：A = [3,4,5,1,2], B = [4,1]
> 输出：true
> ```

```java
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (A == null || B == null ) {
            return false;
        }
        return isSubStructure(A.left, B) || isSubStructure(A.right, B) || isSub(A, B);
    }

    private boolean isSub(TreeNode A, TreeNode B) {
        if (B == null) {
            return true;
        }
        if (A == null) {
            return false;
        }
        return A.val == B.val && isSub(A.left, B.left) && isSub(A.right, B.right);
    }
```

#### [27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

> 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
>
> 例如输入：
>
> ```
>      4
>    /   \
>   2     7
>  / \   / \
> 1   3 6   9
> ```
>
> 镜像输出：
>
> ```
>      4
>    /   \
>   7     2
>  / \   / \
> 9   6 3   1
> ```

```java
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null){
            return null;
        }
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;

        mirrorTree(root.left);
        mirrorTree(root.right);

        return root; 
    }
```

#### [28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

> 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
>
> ```
>     1
>    / \
>   2   2
>  / \ / \
> 3  4 4  3
> ```
>
> 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
>
> ```
>     1
>    / \
>   2   2
>    \   \
>    3    3
> ```

```java
    public boolean isSymmetric(TreeNode root) {
        return root == null ? true : recur(root.left, root.right);
    }
    boolean recur(TreeNode L, TreeNode R) {
        if(L == null && R == null) return true;
        if(L == null || R == null || L.val != R.val) return false;
        return recur(L.left, R.right) && recur(L.right, R.left);
    }
```
#### [32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)
> 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
> 给定二叉树: `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
返回：
```
[3,9,20,15,7]
```
```java
    // 非递归层次遍历
    public int[] levelOrder(TreeNode root) {
        if(root == null){
            return new int[0];
        }
        //用对列存储
        Queue<TreeNode> linkedList = new LinkedList<>();
        List<Integer> list = new ArrayList<>();
        linkedList.add(root);
        while (!linkedList.isEmpty()) {
            TreeNode node = linkedList.poll();
            list.add(node.val);
            if(node.left != null){
                linkedList.add(node.left);
            }
            if(node.right != null){
                linkedList.add(node.right);
            }
        }
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size();i ++) {
            res[i] = list.get(i);
        }
        return res;
    }

    // 递归层次遍历
    public List<List<Integer>> levelOrder2(TreeNode root){  
        List<List<Integer>> list = new ArrayList<>();
        //结果集为list，从root开始遍历，初始层数为0
        helper(list,root,0);
        return list;
    }
    private void helper(List<List<Integer>> list, TreeNode root, int depth) {
        if(root == null){
            return;
        }
        
        if(list.size() == depth){
            list.add(new ArrayList<>());
        }
        list.get(depth).add(root.val);
        
        helper(list, root.left, depth + 1);
        helper(list, root.right, depth + 1);
    }
```
#### [32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)
> 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。例如:给定二叉树: `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
返回其层次遍历结果：
```
[
  [3],
  [9,20],
  [15,7]
]
```
```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>();
        if(root == null){
            return list;
        }
        //用对列存储
        Queue<TreeNode> linkedList = new LinkedList<>();
        linkedList.add(root);
        while (!linkedList.isEmpty()) {
            //count表示每一层的节点数
            int count = linkedList.size();
            //listTmp装每一层的节点，每一层遍历完后就放入list中
            List<Integer> listTmp = new ArrayList<>();
            while(count > 0){
               TreeNode node = linkedList.poll();
               listTmp.add(node.val);
               if(node.left != null){
                    linkedList.add(node.left);
                }
               if(node.right != null){
                    linkedList.add(node.right);
                }
                //每遍历一个，当前层节点数减一
                count --;
            }
            list.add(listTmp);
        }
        return list;
    }
```
#### [32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)
> 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
例如:给定二叉树: [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
```
返回其层次遍历结果：
```
[
  [3],
  [20,9],
  [15,7]
]
```
```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer> > list = new  ArrayList<>();
        if(root == null){
            return list;
        }
        Queue<TreeNode> linkedList = new LinkedList<>();
        linkedList.add(root);
        boolean isReverse = false;
        while(!linkedList.isEmpty()){
            int count = linkedList.size();
            List<Integer> listTmp = new ArrayList<>();
            for(int i = 0;i < count;i ++){
                TreeNode node = linkedList.poll();
                if(node == null){
                    continue;
                }
                if(!isReverse){
                    listTmp.add(node.val);
                }else{
                    listTmp.add(0,node.val);
                }
                if (node.left != null) {
                    linkedList.offer(node.left);
                }
                if (node.right != null) {
                    linkedList.offer(node.right);
                }
            }
            list.add(listTmp);
            isReverse = !isReverse;
        }
        return list;
    }
```
#### [33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)
> 输入一个整数数组，判断该数组是不是某**二叉搜索树**的**后序**遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
参考以下这颗二叉搜索树：
```
     5
    / \
   2   6
  / \
 1   3
 ```
示例 1：
```
输入: [1,6,3,2,5]
输出: false
```
示例 2：
```
输入: [1,3,2,6,5]
输出: true
```
```java
    public boolean verifyPostorder(int[] postorder) {
        if(postorder == null || postorder.length == 0){
            return true;
        }
        return isSequenceOfBST(postorder,0,postorder.length - 1);
    }
    public boolean isSequenceOfBST(int [] sequence,int start,int end){
        if(start >= end){
            return true;
        }
        int val = sequence[end];
        int split = start;
        while(sequence[split] < val){
            split ++;
        }
        //[start,split - 1]位置应该比val小，[split,end - 1]位置应该比val大，
        //所以[split,end - 1]中出现比val小的就直接返回false
        for(int i = split;i <end;i ++){
            if(sequence[i] < val){
                return false;
            }
        }
        return isSequenceOfBST(sequence,start,split - 1) && isSequenceOfBST(sequence,split,end - 1);
    }
```
#### [34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) 回溯
> 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
> 示例:
给定如下二叉树，以及目标和 sum = 22，
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```
返回:
```
[
   [5,4,11,2],
   [5,8,4,5]
]
```
```java
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>(); 
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        helper(root, sum);
        return res;
    }
    void helper(TreeNode root, int tar) {
        if(root == null) return;
        path.add(root.val);
        tar -= root.val;
        if(tar == 0 && root.left == null && root.right == null)
            res.add(new LinkedList(path));
        helper(root.left, tar);
        helper(root.right, tar);
        path.remove(path.size() - 1);
    }
```
#### [37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)
> 请实现两个函数，分别用来**序列化**和**反序列化**二叉树。示例: 你可以将以下二叉树：
```
    1
   / \
  2   3
     / \
    4   5
```
序列化为 `"[1,2,3,null,null,4,5]"`
```java
    public String serialize(TreeNode root) {
        if (root == null) {
            return "[]";
        }
        StringBuilder sb = new StringBuilder("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node != null) {
                sb.append(node.val + ",");
                queue.add(node.left);
                queue.add(node.right);
            } else {
                sb.append("null,");
            }
        }
        sb.deleteCharAt(sb.length() - 1);
        sb.append("]");
        return sb.toString();
    }
    public TreeNode deserialize(String data) {
        if (data.equals("[]"))
            return null;
        String[] vals = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.left);
            }
            i ++;
            if (!vals[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.right);
            }
            i ++;
        }
        return root;
    }
```
### 栈/队列

#### [09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
>
> ```
> 1 <= values <= 10000
> 最多会对 appendTail、deleteHead 进行 10000 次调用
> 
> 示例 1：
> 输入：
> ["CQueue","appendTail","deleteHead","deleteHead"]
> [[],[3],[],[]]
> 输出：[null,null,3,-1]
> 示例 2：
> 
> 输入：
> ["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
> [[],[],[5],[2],[],[]]
> 输出：[null,-1,null,null,5,2]
> ```

```java
class CQueue {
    /** 装数据 */
    Stack<Integer> stack1 = null;
    /** 转移数据 */
    Stack<Integer> stack2 = null;
    
    public CQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        stack1.add(value);
    }
    
    public int deleteHead() {
        int ele = 0;
        if(stack1.isEmpty()){
            ele = -1;
        }else{
            while(stack1.size() > 1){
                stack2.push(stack1.pop());
            }
            ele = stack1.pop();
            while(!stack2.isEmpty()){
                stack1.push(stack2.pop());
            }
        }
        return ele;
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

#### [30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
>
> ```
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.min();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.min();   --> 返回 -2.
> ```
```java
// 数据栈 A ： 栈 A 用于存储所有元素
// 辅助栈 B ： 栈 B 作为降序栈，min() 函数只需返回栈 B 的栈顶元素。
class MinStack {
    Stack<Integer> A, B;
    public MinStack() {
        A = new Stack<>();
        B = new Stack<>();
    }
    public void push(int x) {
        A.push(x);
        // B.peek() >= x 才add，保证降序
        if(B.empty() || B.peek() >= x)
            B.push(x);
    }
    public void pop() {
        if(A.pop().equals(B.peek()))
            B.pop();
    }
    public int top() {
        return A.peek();
    }
    public int min() {
        return B.peek();
    }
}
```

#### [31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)
> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：
```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```
示例 2：
```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```
```java
// 把pushed数组的元素逐个压栈，当栈顶元素 == popped数组中第一个元素，栈顶元素出栈，再用popped数组的第2个元素和栈顶元素比较，如果相同继续出栈……，最后判断栈是否为空
public boolean validateStackSequences(int[] pushed, int[] popped) {
    Stack<Integer> stack = new Stack<>();
    int index = 0;
    for (int val : pushed) {
        //pushed数组中的元素逐个压栈
        stack.push(val);
        while (!stack.empty() && stack.peek() == popped[index]) {
            stack.pop();
            index++;
        }
    }
    return stack.empty();
}
```



### DP

#### [10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项。斐波那契数列的定义如下：
>
> ```
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> ```
>
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> ```
> 0 <= n <= 100
> 
> 示例 1：
> 
> 输入：n = 2
> 输出：1
> 
> 示例 2：
> 
> 输入：n = 5
> 输出：5
> ```

```java
    public int fib(int n) {
        if(n == 0){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        int[] arr = new int[n + 1];
        arr[0] = 0;
        arr[1] = 1;
        for(int i = 2;i <= n;i ++){
            arr[i] = arr[i -1] % 1000000007 + arr[i - 2] % 1000000007;
        }
        return arr[n] % 1000000007;
    }
```

#### [10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> ```
> 0 <= n <= 100
> 
> 示例 1：
> 
> 输入：n = 2
> 输出：2
> 示例 2：
> 
> 输入：n = 7
> 输出：21
> ```

```java
    public int numWays(int n) {
        if(n == 0){
            return 1;
        }
        if(n == 1){
            return 1;
        }
        
        int[] arr = new int[n + 1];
        arr[0] = 1;
        arr[1] = 1;
        for(int i = 2;i <= n;i ++){
            arr[i] = arr[i -1] % 1000000007 + arr[i - 2] % 1000000007;
        }
        return arr[n] % 1000000007;
    }
```

#### [14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。**2 <= n <= 58**
>
> ```
> 示例 1：
> 
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1
> 示例 2:
> 
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
> ```

```java
    public int cuttingRope(int n) {
        //1. 初始判断
        if(n == 2){
            return 1;
        }
        if(n == 3){
            return 2;
        }
        // 2.定义状态
        int[] dp = new int[n + 1];

        // 3.转移方程
        // f(n) = max{1 * f(n - 1),2 * f(n - 2),3 * f(n - 3),4 * f(n - 4) ...}

        // 4.边界
        dp[2] = 1;
        dp[3] = 2;

        // 5.计算
        for(int i = 4;i <= n;i ++){
            for(int j = 1;j < i;j ++){
                // 维持原状态不剪：dp[i]
                // 剪两段：j * (i - j)
                // 剪多段：j * dp[i - j]
                dp[i] = Math.max(Math.max(j * dp[i - j],j * (i - j)),dp[i]);
            }
        }
        return dp[n];
    }
```

#### [14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。**2 <= n <= 1000**
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> ```
> 示例 1：
> 
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1
> 示例 2:
> 
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
> ```

```java
   	import java.math.BigInteger;
	public int cuttingRope(int n) {
        // 1.特殊判断
        if(n==2)
            return 1;
        if(n==3)
            return 2;

        // 2.定义状态，d[i]表示长度为i的绳子剪完后各段乘积的最大值, 最终目标是dp[n]
        BigInteger[] dp = new BigInteger[n+1];

        // 3.转移方程
        //dp[i] = max(dp[i], dp[i-k]*dp[k]);

        // 4.边界情况，下面的初始值不同于上面的特殊情况, 上面是必须剪一刀, 下面的三个初始值不用再减了
        dp[1] = new BigInteger("1");//内循环中会用到这个值
        dp[2] = new BigInteger("2");
        dp[3] = new BigInteger("3");

        // 5.计算
        for(int i=4; i<=n; i++){
            //初始化dp[i]
            dp[i] = new BigInteger("0");
            //长度为i的绳子有i-1个剪切位置; 不论i是奇数还是偶数, 只考虑前i/2个剪切位置即可, 后面的剪切位置是重复的
            for(int j=1; j<=i/2; j++){
                //因为j和i-j都小于i, 所以这是自底向上的计算方式
                dp[i] = dp[i].max(dp[j].multiply(dp[i-j]));
            }
        }
        return dp[n].mod(new BigInteger("1000000007")).intValue();
    }
```

#### [19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

> 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。
>
> ```
> s 可能为空，且只包含从 a-z 的小写字母。
> p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。
> 
> 示例 1:
> 
> 输入:
> s = "aa"
> p = "a"
> 输出: false
> 解释: "a" 无法匹配 "aa" 整个字符串。
> 示例 2:
> 
> 输入:
> s = "aa"
> p = "a*"
> 输出: true
> 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
> 示例 3:
> 
> 输入:
> s = "ab"
> p = ".*"
> 输出: true
> 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
> 示例 4:
> 
> 输入:
> s = "aab"
> p = "c*a*b"
> 输出: true
> 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
> 示例 5:
> 
> 输入:
> s = "mississippi"
> p = "mis*is*p*."
> 输出: false
> ```

```java
    public boolean isMatch(String s, String p) {
        // 1.特判
        if(s==null||p==null)
            return false;
        if (p.length() <= 0) 
            return s.length() <= 0;
        
        // 2.定义状态
        //  dp[i][j]为true表示s的第i个字符到最后一个字符组成的字符串与p的第j个字符到最后一个字符组成的字符串匹配
        int rows = s.length();
        int columns = p.length();
        boolean[][]dp = new boolean[rows+1][columns+1];
        
        // 3.状态转移方程
        //      1.i,j匹配，即字符相等，或者是'.'字符，继续匹配下一个
        //      2.i,j不匹配，是否存在'*'字符
        //          2.1不存在，false
        //          2.2存在，分两种情况，'*'前面字符取0个，'*'前面字符取1个

        // 4.边界
        dp[rows][columns] = true;

        // 5.计算
        for (int i = s.length(); i >= 0; i--){
            for (int j = p.length() - 1; j >= 0; j--){
                boolean curMatch = (i < s.length() &&
                                       (p.charAt(j) == s.charAt(i) ||
                                        p.charAt(j) == '.'));
                if (j + 1 < p.length() && p.charAt(j+1) == '*'){
                    dp[i][j] = dp[i][j+2] || curMatch && dp[i+1][j];
                } else {
                    dp[i][j] = curMatch && dp[i+1][j+1];
                }
            }
        }
        return dp[0][0];
    }
```
#### [42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/) dp
> 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。

示例1:
```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
```java
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length + 1];
        dp[1] = nums[0];
        int res = dp[1];
        for(int i = 2;i <= nums.length;i ++) {
            dp[i] = Math.max(0, dp[i - 1]) + nums[i - 1];
            res = Math.max(res, dp[i]);
        }
        return res;
    }
```


### 贪心

#### [14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。**2 <= n <= 58**
>
> ```
> 示例 1：
> 
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1
> 示例 2:
> 
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
> ```

```java
    public int cuttingRope(int n) {
        //      2: 1 * 1
        //      3: 1 * 2 
        //      4: 1 * 3 < 2 * 2 
        //      5: 1 * 4 < 2 * 3
        //      6: 1 * 5 < 2 * 4(2 * 2 ) < 3 * 3 
        //      7: 1 * 6(3 * 3 ) < 2 * 5(2 * 3) = 3 * 4(2 * 2 )
        //      8: ...
        //  综上，2,3特殊，其他数尽量分解成2和3，由6可得，3比2更优
        //  n % 3= 0/1/2，
        //      如果为0，都为3；
        //      如果为1，最后一个3分为2 * 2；
        //      如果为2，最后一段为2。
        if(n == 2){
            return 1;
        }
        if(n == 3){
            return 2;
        }
        int m = n % 3;

        if(m == 0){
            return (int)Math.pow(3,n / 3);
        }else if(m == 1){
            return (int)Math.pow(3,(n / 3) - 1) * 4;
        }else {
            return (int)Math.pow(3,n / 3) * 2;
        }
    }
```

#### [14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。**2 <= n <= 1000**
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> ```
> 示例 1：
> 
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1
> 示例 2:
> 
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
> ```

```java
    public int cuttingRope(int n) {
        if(n == 2){
            return 1;
        }
        if(n == 3){
            return 2;
        }
        long res = 1;
        
        while(n > 4){
            res = (res * 3) % 1000000007;
            n -= 3;
        }
        return (int)((res * n) % 1000000007) ;
    }
```



### 回溯/DFS/BFS

#### [12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
>
> ```
> [["a","b","c","e"],
> ["s","f","c","s"],
> ["a","d","e","e"]]
> ```
>
> 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
>
> ```
> 1 <= board.length <= 200
> 1 <= board[i].length <= 200
> 
> 示例 1：
> 
> 输入：board = [["A","B","C","E"],
> 			 ["S","F","C","S"],
> 			 ["A","D","E","E"]], 
> 	word = "ABCCED"
> 输出：true
> 示例 2：
> 
> 输入：board = [["a","b"],
> 			 ["c","d"]], 
> 	word = "abcd"
> 输出：false
> 
> ```

```java
    public boolean exist(char[][] board, String word) {
        char[] ch = word.toCharArray();
        // 由于起点任意，所以任何点都可能是起点
        for(int i = 0;i < board.length;i ++){
            for(int j = 0;j < board[0].length;j ++){
                if(dfs(board,i,j,ch,0)){
                    return true;
                }
            }
        }
        return false;
    }
    // board[i][j]位置字符是否等word的k位置字符
    public boolean dfs(char[][] board,int i,int j,char[] ch,int k){
        // 退出条件：i越界或j越界或不匹配
        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != ch[k]){
            return false;
        }
        // word整个单词都匹配完了，返回true
        if(k == ch.length - 1){
            return true;
        }
        // board[i][j]与word的k位置匹配，继续向[i][j]的上下左右位置匹配word的k + 1位置字符
        // 因为不能重复匹配，所以将[i][j]位置字符修改，匹配完后要还原
        char tmp = board[i][j];
        board[i][j] = '*';
        
        boolean res = dfs(board,i + 1,j,ch,k + 1) || dfs(board,i - 1,j,ch,k + 1)  || dfs(board,i,j + 1,ch,k + 1) || dfs(board,i,j - 1,ch,k + 1);
        
        board[i][j] = tmp;

        return res;
    }
```

#### [13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

> 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
>
> ```
> 1 <= n,m <= 100
> 0 <= k <= 20
> 
> 示例 1：
> 
> 输入：m = 2, n = 3, k = 1
> 输出：3
> 示例 2：
> 
> 输入：m = 3, n = 1, k = 0
> 输出：1
> ```

```java
    // 记录总数量
    int count = 0;
    public int movingCount(int m, int n, int k) {
        // 标记当前位置是否访问过
        boolean[][] isVisited = new boolean[m][n];
        return dfs(0,0,m,n,k,isVisited);
    }
    // 走到(i,j)位置，三层判断：1.是否越界；2.数位和是否符合；3.是否已访问过
    public int dfs(int i,int j,int m,int n,int k,boolean[][] isVisited){
        if(i < 0 || i >= m || j < 0 || j >= n || !canVisit(i,j,k) || isVisited[i][j]){
            return 0;
        }
        // 修改当前位置为已访问过
        isVisited[i][j] = true;
        // 1 + 后续遍历位置
        count =1 + dfs(i + 1,j,m,n,k,isVisited)
                 + dfs(i - 1,j,m,n,k,isVisited)
                 + dfs(i,j + 1,m,n,k,isVisited)
                 + dfs(i,j - 1,m,n,k,isVisited);
        return count;
    }
    // 计算(i,j)数位和
    public boolean canVisit(int i,int j,int k){
        int sum = 0;
        while(i != 0){
            sum += i % 10;
            i  /= 10;
        }
        while(j != 0){
            sum += j % 10;
            j  /= 10;
        }
        return sum > k ? false : true;
    }
```

### 二进制

#### [15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

> 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
>
> ```
> 示例 1：
> 
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
> 示例 2：
> 
> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
> 示例 3：
> 
> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
> ```

```java
    public int hammingWeight(int n) {
        int count = 0;
        while(n != 0){
            n = n & (n - 1);
            count ++;
        }
        return count;
    }
```

#### [16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)--快速幂

> 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
>
> ```
> -100.0 < x < 100.0
> n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
> 
> 示例 1:
> 
> 输入: 2.00000, 10
> 输出: 1024.00000
> 示例 2:
> 
> 输入: 2.10000, 3
> 输出: 9.26100
> 示例 3:
> 
> 输入: 2.00000, -2
> 输出: 0.25000
> 解释: 2-2 = 1/22 = 1/4 = 0.25
> ```

```java
    public double myPow(double x, int n) {
        // 特殊判断
        if(x == 0){
            return 0;
        }

        // 如果n为 -2147483648，那么直接取 -n会超出整型范围，所以这里用long型的count表示幂
        boolean isNeg = n < 0 ;
        long count = n;
        count = isNeg ? -count : count;

        // 计算结果，
        //  如果直接遍历count次，那么时间复杂度是O(n)，超时
        //  对于x^count，
        //      如果count为偶数，可以转为 (x^2)^(count / 2)；
        //      如果count为奇数，转为 x *(x^2)^(count / 2)，即另外再乘一个x
        //  这样计算每次n >> 1，时间复杂度是O(lgn)级别
        double res = 1.0;
        while(count > 0){
            if((count & 1) == 1){
                res *= x;
            }
            x *= x;
            count = count >> 1;
        }
        return isNeg ? 1 / res : res;
    }
```

#### [17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)--快速幂

> 输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
>
> ```
> 用返回一个整数列表来代替打印
> n 为正整数
> 
> 示例 1:
> 
> 输入: n = 1
> 输出: [1,2,3,4,5,6,7,8,9]
> ```

```java
	// 方法一，计算 10 ^ n - 1 
	public int[] printNumbers(int n) {
        int total = 9;
        n --;
        while (n != 0){
            total = total * 10 + 9;
            n --;
        }
        int[] arr = new int[total];
        for (int i = 0; i < total; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }
	
	// 方法二，利用库函数计算 10 ^ n再减1
    public int[] printNumbers(int n) {
        double max = Math.pow(10, n);
        int total = (int) max-1;
        // 计算长度
        int[] arr = new int[total];
        for (int i = 0; i < total; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }

	// 利用快速幂计算10 ^ n再减1
    public int[] printNumbers(int n) {
        int total = 1;
        int x = 10;
        while(n > 0){
            if((n & 1) == 1){
                total *= x;
            }
            x *= x;
            n >>= 1;
        }
        // 计算长度
        int[] arr = new int[total - 1];
        for (int i = 0; i < total - 1; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }

```

### 字符串

#### [20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"、"-1E-16"及"12e+5.4"都不是。

```java
    public boolean isNumber(String s) {
        // 数据初始化去除首位空字符
        s = s.trim();
        if(s.length() == 0) {
            return false;
        }
        int i = 0;
        // 符号部分处理
        if(s.charAt(i) == '-' || s.charAt(i) == '+') {
            i++;
        }
        int pointNum = 0;
        int digitalNum = 0;
        // 小数部分处理（包含小数点与正整数）
        while(i < s.length() && (s.charAt(i) >= '0' && s.charAt(i) <= '9' || s.charAt(i) == '.')) {
            if(s.charAt(i) == '.') {
                pointNum++;
            }else {
                digitalNum++;
            }
            i++;
        }
        if(pointNum > 1 || digitalNum < 1) {
            return false;
        }
        // 如果没有指数e部分就返回true
        if(i == s.length()) {
            return true;
        }
        // 如果字符串还没到尾，说明可能存在指数部分 e
        if(s.charAt(i) == 'e') {
            i++;
            // 如果指数字母e后面啥都没有了，则false
            if(i == s.length()) {
                return false;
            }
            // e的幂可能会有符号
            if(s.charAt(i) == '-' || s.charAt(i) == '+') {
                i++;
                // 如果符号后面啥都没有到尾了，false，因为必须跟数字的
                if(i == s.length()) {
                    return false;
                }
            }
            // 处理幂的数字部分
            while(i < s.length() && (s.charAt(i) >= '0' && s.charAt(i) <= '9')) {
                i++;
            }
            // 如果数字部分结束就到尾了，返回true
            if(i == s.length()) {
                return true;
            }
        }
        // 其他杂七杂八的情况都false，如有其他特殊字符abcd之类的
        return false;
    }
```
#### [38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
> 输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
示例:
```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```
```java
    Set<String> result = new HashSet<>();
    public String[] permutation(String s) {
        if (s == null) 
            return  new String[]{};
        boolean[] visited = new boolean[s.length()];
        process(s, "", visited);
        return result.toArray(new String[result.size()]);
    } 
    private void process(String s, String letter, boolean[]visited) {
        if (s.length() == letter.length()) {
            result.add(letter);
            return;
        }
        for (int i = 0;i < s.length();i ++) {
            char tmp = s.charAt(i);
            if (visited[i]) {
                continue;
            }
            visited[i] = true;
            process(s, letter + String.valueOf(tmp), visited);
            visited[i] = false;
        }
    }
```
### 其他
#### [43. 1～n整数中1出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)
> 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

示例 1：
```
输入：n = 12
输出：5
```
示例 2：
```
输入：n = 13
输出：6
```
```java
       // 个位：k = n % 10，    n / 10    * 1    + if (k >= 1   ) 1     else if (k < 1   ) 0 else k - 1      + 1
       // 十位：k = n % 100，   n / 100   * 10   + if (k >= 19  ) 10    else if (k < 10  ) 0 else k - 10     + 1
       // 百位：k = n % 1000，  n / 1000  * 100  + if (k >= 199 ) 100   else if (k < 100 ) 0 else k - 100    + 1

 // 所以： x位  k = n % 10x     n / 10x   * x    + if (k >= 2x-1) x     else if (k < x   ) 0 else k  - x     + 1

    public int countDigitOne(int n) {
        if(n <=0){
            return 0;
        }
        long count = 0;
        long tmp = 0;
        //从个、十、百到...小于n的最大10的倍数位
        for(long i = 1;i <= n;i = i * 10){
            tmp = 0;
            long k = n % (10 * i);
            //保存上述公式中的 n / 10x  * x
            tmp = n / (10 * i) * i;
            //根据余数情况计算后续1的位数
            if(k > 2 * i -1){
                count += tmp + i;
            }else if(k < i){
                count += tmp;
            }else{
                count += tmp + k -i + 1;
            }
        }    
        return (int)count;
    }
```
#### [44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)
> 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。

示例 1：
```
输入：n = 3
输出：3
```
示例 2：
```
输入：n = 11
输出：0
```
```java

```